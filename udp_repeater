#!/bin/env ruby

require 'socket'
require 'ipaddr'
require 'securerandom'

# UDP repeater
sport = nil
cport = nil
chost = nil
rport = nil
rhost = nil
lport = nil

b = binding
begin
    if ARGV.delete "--server"
        ARGV.each do |arg|
            case arg
            when /^\d+$/
                if !sport
                    sport = arg.to_i
                else
                    cport = arg.to_i
                    chost = "127.0.0.1"
                end
            when /^([A-Aa-z0-9\.\-]+):(\d+)$/
                chost = $1
                cport = $2
            else
                raise ArgumentError.new("Invalid argument")
            end
        end
    else
        ARGV.each do |arg|
            case arg
            when /^\d+$/
                lport = arg.to_i
            when /^([A-Aa-z0-9\.\-]+):(\d+)$/
                rhost = $1
                rport = $2
            else
                raise ArgumentError.new("Invalid argument")
            end
        end
        if !lport || !rport || !rhost
            raise ArgumentError.new("Invalid argument")
        end
    end
rescue ArgumentError
    STDERR.puts <<END
Usage: udp_repeater <local_port> <remote_host:remote_port>
       udp_repeater --server <local_port> <connection_host:connection_port>
END
    exit 1
end

SPORT = sport
CPORT = cport
CHOST = chost
RPORT = rport
RHOST = rhost
LPORT = lport

require 'fileutils'

if LPORT
    id = IO.read "#{ENV['HOME']}/.udp_repeater/id" rescue (
        FileUtils.mkdir_p "#{ENV['HOME']}/.udp_repeater"
        IO.write "#{ENV['HOME']}/.udp_repeater/id", id = SecureRandom.random_bytes(32);
        id
    )
end
ID = id

repeat = nil
begin
    repeat = IO.read("#{ENV['HOME']}/.udp_repeater/repeat").to_i
    if repeat < 1
        raise ArgumentError.new("Invalid repeat value")
    end
rescue
    FileUtils.mkdir_p "#{ENV['HOME']}/.udp_repeater"
    IO.write "#{ENV['HOME']}/.udp_repeater/repeat", "7";
    repeat = 7
end
REPEAT = repeat


Counter = Hash.new { |h, k| h[k] = 0 }
PacketSz = 1024


class PacketQueue
    Data = Hash.new
    def self.emerge addr, port
        Data[[addr, port]] ||= new
    end
    def initialize
        @chunkManagers = Hash.new
        @queue = Array.new
    end
    def getChunkManager packet_no
        if @first && packet_no < @first - 100 ||  @last && @last + 100 < packet_no
            @queue.clear
            @first = nil
        end
        @first ||= packet_no
        pos = packet_no - @first
        if pos < 0
            @first = packet_no
            while pos < 0
                @queue.unshift ChunkManager.new
                pos += 1
            end
        elsif pos > @queue.size
            (pos - @queue.size).times do
                @queue.push ChunkManager.new
            end
        end
        @queue[pos] ||= ChunkManager.new

    end
    def flush
        while !@queue.empty? && @queue.first.ready?
            @queue.shift.flush do |tdata|
                yield tdata
            end
        end
    end
end

MaxChunkSize = 5
Timeout = 5

class ChunkManager
    Data = Hash.new
    def self.register addr, port, packet_no, chunk_no, data_size, data
        pq = PacketQueue.emerge addr, port
        cm = pq.getChunkManager packet_no
        cm.addChunk chunk_no, data_size, data
        pq.flush do |tdata|
            yield tdata
        end
    end
    def initialize
        @time = Time.now
        @chunks = Array.new
        @size = 0
    end
    def addChunk chunk_no, data_size, data
        @chunks[chunk_no] && return
        @chunks[chunk_no] = data
        @size += data.size
        if @size >= data_size
            @data_ready = true
        end
    end
    def flush
        if @data_ready
            d = @chunks.join rescue nil
            yield d if d
        end
    end
    def ready?
        (Time.now - @time) > Timeout || @data_ready
    end
end

RcvPacketSz = 65536
SndPacketSz = 1200

if LPORT # client

    def main
        lsocket = UDPSocket.new
        lsocket.bind('0.0.0.0', LPORT)
        rsocket = UDPSocket.new
        rsocket.bind('0.0.0.0', 0)
        loop do
            p 0
            rs, = select [lsocket, rsocket], nil, nil
            p rs
            if rs
                p 1
                if rs.include? lsocket
                    p 2
                    data, _addr = lsocket.recvfrom(RcvPacketSz)
                    oaddr = _addr[3]
                    oport = _addr[1]
                    packet_no = Counter[[addr, port]] += 1
                    chunk_no = 0
                    data_size = data.size
                    p data_size
                    p data
                    cur_pos = 0
                    chunk_no = 0
                    loop do
                        p 3
                        header = Marshal.dump [oaddr, oport, packet_no, chunk_no, data_size, ID]
                        header_sz = header.size
                        p header_sz
                        chunk_sz_max = SndPacketSz - 4 - header_sz
                        chunk_sz = [chunk_sz_max, data_size - cur_pos].min
                        p chunk_sz
                        data_chunk = data[cur_pos, chunk_sz]
                        cur_pos += chunk_sz
                        to_send = [header_sz, chunk_sz].pack('S<S<') + header + data_chunk
                        puts "Packed data: #{to_send.bytes}"
                        REPEAT.times do
                            rsocket.send(to_send, 0, RHOST, RPORT)
                        end
                        chunk_no += 1
                        break if cur_pos >= data_size
                    end
                end
                if rs.include? rsocket
                    p 4
                    data, = rsocket.recvfrom(RcvPacketSz)
                    header_sz, chunk_sz = data[0..3].unpack('S<S<')
                    header = data[4, header_sz]
                    oaddr, oport, packet_no, chunk_no, data_size, id = Marshal.load(header) rescue nil
                    p oaddr
                    p oport
                    p packet_no
                    p chunk_no
                    p data_size
                    p id
                    p ID
                    next if id != ID
                    p :sending
                    ChunkManager.register oaddr, oport, packet_no, chunk_no, data_size, data[4 + header_sz, chunk_sz] do |tdata|
                        lsocket.send(tdata, 0, oaddr, oport)
                    end
                end
            end
        end
    end

else # server
    class UDPSocket
        def set_pinfo paddr, pport, oaddr, oport, id
            @paddr = paddr
            @pport = pport
            @oaddr = oaddr
            @oport = oport
            @id = id
            self
        end
        attr_reader :paddr, :pport, :oaddr, :oport, :id
    end

    def main
        ssocket = UDPSocket.new
        ssocket.bind('0.0.0.0', SPORT)
        csocketList = {}
        loop do
            rs, = select [ssocket, *csocketList.values], nil, nil
            if rs
                rs.each do |socket|
                    if csocketList.values.include? socket
                        data, _addr = socket.recvfrom(RcvPacketSz)
                        addr = _addr[3]
                        port = _addr[1]
                        packet_no = Counter[[addr, port]] += 1
                        chunk_no = 0
                        data_size = data.size
                        cur_pos = 0
                        loop do
                            header = Marshal.dump [socket.oaddr, socket.oport, packet_no, chunk_no, data_size, socket.id]
                            header_sz = header.size
                            p header_sz
                            chunk_sz_max = SndPacketSz - 4 - header_sz
                            chunk_sz = [chunk_sz_max, data_size - cur_pos].min
                            p chunk_sz
                            data_chunk = data[cur_pos, chunk_sz]
                            cur_pos += chunk_sz
                            to_send = [header_sz, chunk_sz].pack('S<S<') + header + data_chunk
                            REPEAT.times do
                                socket.send(to_send, 0, socket.paddr, socket.pport)
                            end
                            chunk_no += 1
                            break if cur_pos >= data_size
                        end
                    elsif socket == ssocket
                        data, _addr = ssocket.recvfrom(RcvPacketSz)
                        paddr = _addr[3]
                        pport = _addr[1]
                        header_sz, chunk_sz = data[0..3].unpack('S<S<')
                        header = data[4, header_sz]
                        oaddr, oport, packet_no, chunk_no, data_size, id = Marshal.load(header) rescue nil
                        csocket = csocketList[[addr, port, id]]
                        if !csocket
                            s = UDPSocket.new
                            csocketList[[addr, port, id]] = s
                            s.bind('0.0.0.0', 0)
                            s.set_pinfo(paddr, pport, oaddr, oport, id)
                            csocket = s
                        end
                        p [header_sz, chunk_sz]
                        ChunkManager.register addr, port, packet_no, chunk_no, data_size, data[4 + header_sz, chunk_sz] do |tdata|
                            p tdata
                            p csocket
                            csocket.send(tdata, 0, CHOST, CPORT)
                        end
                    end
                end
            end
        end
    end

end

main


